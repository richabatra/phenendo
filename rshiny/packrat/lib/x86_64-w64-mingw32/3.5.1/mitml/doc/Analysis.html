<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Example data (<code>studentratings</code>)</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>This vignette is intended to provide an overview of the analysis of multiply imputed data sets with <code>mitml</code>.
Specifically, this vignette addresses the following topics:</p>

<ol>
<li>Working with multiply imputed data sets</li>
<li>Rubin&#39;s rules for pooling individual parameters</li>
<li>Model comparisons</li>
<li>Parameter constraints</li>
</ol>

<p>Further information can be found in the other <a href="https://github.com/simongrund1/mitml/wiki">vignettes</a> and the package <a href="https://cran.r-project.org/package=mitml/mitml.pdf">documentation</a>.</p>

<h2>Example data (<code>studentratings</code>)</h2>

<p>For the purposes of this vignette, we make use of the <code>studentratings</code> data set, which contains simulated data from 750 students in 50 schools including scores on reading and math achievement, socioeconomic status (SES), and ratings on school and classroom environment.</p>

<p>The package and the data set can be loaded as follows.</p>

<pre><code class="r">library(mitml)
library(lme4)
data(studentratings)
</code></pre>

<p>As evident from its <code>summary</code>, most variables in the data set contain missing values.</p>

<pre><code class="r">summary(studentratings)
</code></pre>

<pre><code>#        ID       FedState     Sex              MathAchiev       MathDis      
#  Min.   :1001   B :375   Length:750         Min.   :225.0   Min.   :0.2987  
#  1st Qu.:1013   SH:375   Class :character   1st Qu.:440.7   1st Qu.:1.9594  
#  Median :1513            Mode  :character   Median :492.7   Median :2.4350  
#  Mean   :1513                               Mean   :495.4   Mean   :2.4717  
#  3rd Qu.:2013                               3rd Qu.:553.2   3rd Qu.:3.0113  
#  Max.   :2025                               Max.   :808.1   Max.   :4.7888  
#                                             NA&#39;s   :132     NA&#39;s   :466     
#       SES          ReadAchiev       ReadDis        CognAbility      SchClimate     
#  Min.   :-9.00   Min.   :191.1   Min.   :0.7637   Min.   :28.89   Min.   :0.02449  
#  1st Qu.:35.00   1st Qu.:427.4   1st Qu.:2.1249   1st Qu.:43.80   1st Qu.:1.15338  
#  Median :46.00   Median :490.2   Median :2.5300   Median :48.69   Median :1.65636  
#  Mean   :46.55   Mean   :489.9   Mean   :2.5899   Mean   :48.82   Mean   :1.73196  
#  3rd Qu.:59.00   3rd Qu.:558.4   3rd Qu.:3.0663   3rd Qu.:53.94   3rd Qu.:2.24018  
#  Max.   :93.00   Max.   :818.5   Max.   :4.8554   Max.   :71.29   Max.   :4.19316  
#  NA&#39;s   :281                     NA&#39;s   :153                      NA&#39;s   :140
</code></pre>

<p>In the present example, we investigate the differences in mathematics achievement that can be attributed to differences in SES when controlling for students&#39; sex.
Specifically, we are interested in the following model.</p>

<p>\[
\mathit{MA}_{ij} = \gamma_{00} + \gamma_{10} \mathit{Sex}_{ij} + \gamma_{20} (\mathit{SES}_{ij}-\overline{\mathit{SES}}_{\bullet j}) + \gamma_{01} \overline{\mathit{SES}}_{\bullet j} + u_{0j} + e_{ij}
\]</p>

<p>Note that this model also employs group-mean centering to separate the individual and group-level effects of SES.</p>

<h2>Generating imputations</h2>

<p>In the present example, we generate 20 imputations from the following imputation model.</p>

<pre><code class="r">fml &lt;- ReadDis + SES ~ 1 + Sex + (1|ID)
imp &lt;- panImpute(studentratings, formula=fml, n.burn=5000, n.iter=200, m=20)
</code></pre>

<p>The completed data are then extracted with <code>mitmlComplete</code>.</p>

<pre><code class="r">implist &lt;- mitmlComplete(imp, &quot;all&quot;)
</code></pre>

<h2>Transforming the imputed data sets</h2>

<p>In empirical research, the raw data rarely enter the analyses but often require to be transformed beforehand.
For this purpose, the <code>mitml</code> package provides the <code>within</code> function, which applies a given transformation directly to each data set.</p>

<p>In the following, we use this to (a) calculate the group means of SES and (b) center the individual scores around their group means.</p>

<pre><code class="r">implist &lt;- within(implist,{
  G.SES &lt;- clusterMeans(SES,ID) # calculate group means
  I.SES &lt;- SES - G.SES          # center around group means
})
</code></pre>

<p>This method can be used to apply arbitrary transformations to all of the completed data sets simultaneously.</p>

<blockquote>
<p><strong>Note regarding</strong> <code>dplyr</code><strong>:</strong>
Due to how it is implemented, <code>within</code> cannot be used directly with <code>dplyr</code>.
Instead, users may use <code>with</code> instead of <code>within</code> with the following workaround.</p>

<pre><code class="r">implist &lt;- with(implist,{
  df &lt;- data.frame(as.list(environment()))
  df &lt;- ... # dplyr commands
  df
})
implist &lt;- as.mitml.list(implist)
</code></pre>

<p>Advanced users may also consider using <code>lapply</code> for a similar workaround.<span style="color:white"></span></p>
</blockquote>

<h2>Fitting the analysis model</h2>

<p>In order to analyze the imputed data, each data set is analyzed using regular complete-data techniques.
For this purpose, <code>mitml</code> offers the <code>with</code> function.
In the present example, we use it to fit the model of interest with the R package <code>lme4</code>.</p>

<pre><code class="r">fit &lt;- with(implist,{
  lmer(MathAchiev ~ 1 + Sex + I.SES + G.SES + (1|ID))
})
</code></pre>

<p>This results in a list of fitted models, one for each of the imputed data sets.</p>

<h2>Pooling</h2>

<p>The results obtained from the imputed data sets must be pooled in order to obtain a set of final parameter estimates and inferences.
In the following, we employ a number of different pooling methods that can be used to address common statistical tasks, for example, for (a) estimating and testing individual parameters, (b) model comparisons, and &copy; tests of constraints about one or several parameters.</p>

<h4>Parameter estimates</h4>

<p>Individual parameters are commonly pooled with the rules developed by Rubin (1987).
In <code>mitml</code>, Rubin&#39;s rules are implemented in the <code>testEstimates</code> function.</p>

<pre><code class="r">testEstimates(fit)
</code></pre>

<pre><code># 
# Call:
# 
# testEstimates(model = fit)
# 
# Final parameter estimates and inferences obtained from 20 imputed data sets.
# 
#               Estimate  Std.Error    t.value         df    P(&gt;|t|)        RIV        FMI 
# (Intercept)    433.015     28.481     15.203   1081.280      0.000      0.153      0.134 
# SexGirl          3.380      7.335      0.461 279399.841      0.645      0.008      0.008 
# I.SES            0.692      0.257      2.690    233.427      0.008      0.399      0.291 
# G.SES            1.296      0.597      2.173   1096.956      0.030      0.152      0.133 
# 
# Unadjusted hypothesis test as appropriate in larger samples.
</code></pre>

<p>In addition, the argument <code>var.comp=TRUE</code> can be used to obtain pooled estimates of variance components, and <code>df.com</code> can be used to specify the complete-data degrees of freedom, which provides more appropriate (i.e., conservative) inferences in smaller samples.</p>

<p>For example, using a conservative value for the complete-data degrees of freedom for the fixed effects in the model of interest (Snijders &amp; Bosker, 2012), the output changes as follows.</p>

<pre><code class="r">testEstimates(fit, var.comp=TRUE, df.com=46)
</code></pre>

<pre><code># 
# Call:
# 
# testEstimates(model = fit, var.comp = TRUE, df.com = 46)
# 
# Final parameter estimates and inferences obtained from 20 imputed data sets.
# 
#              Estimate Std.Error   t.value        df   P(&gt;|t|)       RIV       FMI 
# (Intercept)   433.015    28.481    15.203    36.965     0.000     0.153     0.134 
# SexGirl         3.380     7.335     0.461    43.752     0.647     0.008     0.008 
# I.SES           0.692     0.257     2.690    27.781     0.012     0.399     0.291 
# G.SES           1.296     0.597     2.173    37.022     0.036     0.152     0.133 
# 
#                         Estimate 
# Intercept~~Intercept|ID  168.506 
# Residual~~Residual      8092.631 
# ICC|ID                     0.020 
# 
# Hypothesis test adjusted for small samples with df=[46]
# complete-data degrees of freedom.
</code></pre>

<h4>Multiple parameters and model comparisons</h4>

<p>Oftentimes, statistical inference concerns more than one parameter at a time.
For example, the combined influence of SES (within and between groups) on mathematics achievement is represented by two parameters in the model of interest.</p>

<p>Multiple pooling methods for Wald and likelihood ratio tests (LRTs) are implemented in the <code>testModels</code> function.
This function requires the specification of a full model and a restricted model, which are then compared using (pooled) Wald tests or LRTs.
Specifically, <code>testModels</code> allows users to pool Wald tests (\(D_1\)), \(\chi^2\) test statistics (\(D_2\)), and LRTs (\(D_3\); for a comparison of these methods, see also Grund, Lüdtke, &amp; Robitzsch, 2016b).</p>

<p>To examine the combined influence of SES on mathematics achievement, the following restricted model can be specified and compared with the model of interest (using \(D_1\)).</p>

<pre><code class="r">fit.null &lt;- with(implist,{
  lmer(MathAchiev ~ 1 + Sex + (1|ID))
})

testModels(fit, fit.null)
</code></pre>

<pre><code># 
# Call:
# 
# testModels(model = fit, null.model = fit.null)
# 
# Model comparison calculated from 20 imputed data sets.
# Combination method: D1 
# 
#    F.value     df1     df2   P(&gt;F)     RIV 
#      6.095       2 674.475   0.002   0.275 
# 
# Unadjusted hypothesis test as appropriate in larger samples.
</code></pre>

<blockquote>
<p><strong>Note regarding the order of arguments:</strong>
Please note that <code>testModels</code> expects that the first argument contains the full model, and the second argument contains the restricted model.
If the order of the arguments is reversed, the results will not be interpretable.</p>
</blockquote>

<p>Similar to the test for individual parameters, smaller samples can be accommodated with <code>testModels</code> (with method \(D_1\)) by specifying the complete-data degrees of freedom for the denominator of the \(F\) statistic.</p>

<pre><code class="r">testModels(fit, fit.null, df.com=46)
</code></pre>

<pre><code># 
# Call:
# 
# testModels(model = fit, null.model = fit.null, df.com = 46)
# 
# Model comparison calculated from 20 imputed data sets.
# Combination method: D1 
# 
#    F.value     df1     df2   P(&gt;F)     RIV 
#      6.095       2  40.687   0.005   0.275 
# 
# Hypothesis test adjusted for small samples with df=[46]
# complete-data degrees of freedom.
</code></pre>

<p>The pooling method used by <code>testModels</code> is determined by the <code>method</code> argument.
For example, to calculate the pooled LRT corresponding to the Wald test above (i.e., \(D_3\)), the following command can be issued.</p>

<pre><code class="r">testModels(fit, fit.null, method=&quot;D3&quot;)
</code></pre>

<pre><code># 
# Call:
# 
# testModels(model = fit, null.model = fit.null, method = &quot;D3&quot;)
# 
# Model comparison calculated from 20 imputed data sets.
# Combination method: D3 
# 
#    F.value     df1     df2   P(&gt;F)     RIV 
#      5.787       2 519.143   0.003   0.328 
# 
# Models originally fit with REML were automatically refit using ML.
</code></pre>

<h4>Constraints on parameters</h4>

<p>Finally, it is often useful to investigate functions (or constraints) of the parameters in the model of interest.
In complete data sets, this can be achieved with a test of linear hypotheses or the delta method.
The <code>mitml</code> package implements a pooled version of the delta method in the <code>testConstraints</code> function.</p>

<p>For example, the combined influence of SES on mathematics achievement can also be tested without model comparisons by testing the constraint that the parameters pertaining to <code>I.SES</code> and <code>G.SES</code> are both zero.
This constraint is defined and tested as follows.</p>

<pre><code class="r">c1 &lt;- c(&quot;I.SES&quot;, &quot;G.SES&quot;)
testConstraints(fit, constraints=c1)
</code></pre>

<pre><code># 
# Call:
# 
# testConstraints(model = fit, constraints = c1)
# 
# Hypothesis test calculated from 20 imputed data sets. The following
# constraints were specified:
# 
#             Estimate Std. Error 
#    I.SES:      0.692      0.245 
#    G.SES:      1.296      0.628 
# 
# Combination method: D1 
# 
#    F.value     df1     df2   P(&gt;F)     RIV 
#      6.095       2 674.475   0.002   0.275 
# 
# Unadjusted hypothesis test as appropriate in larger samples.
</code></pre>

<p>This test is identical to the Wald test given in the previous section.
Arbitrary constraints on the parameters can be specified and tested in this manner, where each character string denotes an expression to be tested against zero.</p>

<p>In the present example, we are also interested in the <em>contextual</em> effect of SES on mathematics achievement (e.g., Snijders &amp; Bosker, 2012).
The contextual effect is simply the difference between the coefficients pertaining to <code>G.SES</code> and <code>I.SES</code> and can be tested as follows.</p>

<pre><code class="r">c2 &lt;- c(&quot;G.SES - I.SES&quot;)
testConstraints(fit, constraints=c2)
</code></pre>

<pre><code># 
# Call:
# 
# testConstraints(model = fit, constraints = c2)
# 
# Hypothesis test calculated from 20 imputed data sets. The following
# constraints were specified:
# 
#                     Estimate Std. Error 
#    G.SES - I.SES:      0.605      0.644 
# 
# Combination method: D1 
# 
#    F.value     df1     df2   P(&gt;F)     RIV 
#      0.881       1 616.380   0.348   0.166 
# 
# Unadjusted hypothesis test as appropriate in larger samples.
</code></pre>

<p>Similar to model comparisons, constraints can be tested with different methods (\(D_1\) and \(D_2\)) and can accommodate smaller samples by a value for <code>df.com</code>.
Further examples for the analysis of multiply imputed data sets with <code>mitml</code> are given by Enders (2016) and Grund, Lüdtke, and Robitzsch (2016a).</p>

<h6>References</h6>

<p>Enders, C. K. (2016). Multiple imputation as a flexible tool for missing data handling in clinical research. <em>Behaviour Research and Therapy</em>. doi: 10.1016/j.brat.2016.11.008 (<a href="https://doi.org/10.1016/j.brat.2016.11.008">Link</a>)</p>

<p>Grund, S., Lüdtke, O., &amp; Robitzsch, A. (2016a). Multiple imputation of multilevel missing data: An introduction to the R package pan. <em>SAGE Open</em>, <em>6</em>(4), 1–17. doi: 10.1177/2158244016668220 (<a href="https://doi.org/10.1177/2158244016668220">Link</a>)</p>

<p>Grund, S., Lüdtke, O., &amp; Robitzsch, A. (2016b). Pooling ANOVA results from multiply imputed datasets: A simulation study. <em>Methodology</em>, <em>12</em>, 75–88. doi: 10.1027/1614-2241/a000111 (<a href="https://doi.org/10.1027/1614-2241/a000111">Link</a>)</p>

<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>. Hoboken, NJ: Wiley.</p>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (2012). <em>Multilevel analysis: An introduction to basic and advanced multilevel modeling</em>. Thousand Oaks, CA: Sage.</p>

<hr/>

<pre><code># Author: Simon Grund (grund@ipn.uni-kiel.de)
# Date:   2018-07-10
</code></pre>

</body>

</html>
